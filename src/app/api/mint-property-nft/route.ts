import { NextRequest, NextResponse } from 'next/server';

const PINATA_JWT = process.env.PINATA_JWT;
const SOLANA_NETWORK = process.env.NEXT_PUBLIC_SOLANA_NETWORK || 'devnet';

export async function POST(request: NextRequest) {
  try {
    const { propertyData, aiInsights, userWalletAddress } = await request.json();
    
    console.log('üé® Starting NFT minting process...');
    
    // Step 1: Prepare metadata
    // Note: NFT name must be <= 32 characters for Solana
    const shortAddress = propertyData.address.length > 25 
      ? propertyData.address.substring(0, 25) + '...'
      : propertyData.address;
    
    const nftName = `HomePilot #${propertyData.zpid.substring(0, 6)}`;
    
    const metadata = {
      name: nftName, // Short name for on-chain (max 32 chars)
      symbol: 'HOMEAI',
      description: `AI-powered property analysis generated by HomePilot for ${propertyData.address}. Affordability Score: ${aiInsights.affordabilityScore}/100`,
      image: propertyData.imgSrc || propertyData.carouselPhotos[0]?.url,
      external_url: `https://homepilot.ai/property/${propertyData.zpid}`,
      attributes: [
        { trait_type: 'Full Address', value: propertyData.address },
        { trait_type: 'Price', value: propertyData.price.toString() },
        { trait_type: 'Bedrooms', value: propertyData.bedrooms.toString() },
        { trait_type: 'Bathrooms', value: propertyData.bathrooms.toString() },
        { trait_type: 'Square Feet', value: propertyData.sqft.toString() },
        { trait_type: 'Affordability Score', value: aiInsights.affordabilityScore.toString() },
        { trait_type: 'Affordability Level', value: aiInsights.affordabilityLevel },
        { trait_type: 'DTI Ratio', value: `${aiInsights.dtiRatio.toFixed(1)}%` },
        { trait_type: 'Monthly Payment', value: aiInsights.monthlyPayment.toString() },
        { trait_type: 'Analysis Date', value: new Date().toISOString().split('T')[0] },
        { trait_type: 'City', value: propertyData.addressCity },
        { trait_type: 'State', value: propertyData.addressState },
        { trait_type: 'Zip Code', value: propertyData.addressZipcode },
      ],
      properties: {
        files: [
          {
            uri: propertyData.imgSrc || propertyData.carouselPhotos[0]?.url,
            type: 'image/jpeg',
          },
        ],
        category: 'image',
        full_analysis: {
          property: propertyData,
          insights: aiInsights,
          generated_at: new Date().toISOString(),
        },
      },
    };
    
    console.log('üì¶ Metadata prepared');
    
    // Step 2: Upload to IPFS via Pinata
    if (PINATA_JWT) {
      console.log('‚òÅÔ∏è Uploading to IPFS via Pinata...');
      
      try {
        const pinataResponse = await fetch('https://api.pinata.cloud/pinning/pinJSONToIPFS', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${PINATA_JWT}`,
          },
          body: JSON.stringify({
            pinataContent: metadata,
            pinataMetadata: {
              name: `property-analysis-${propertyData.zpid}.json`,
            },
          }),
        });

        if (pinataResponse.ok) {
          const pinataData = await pinataResponse.json();
          const metadataUri = `https://gateway.pinata.cloud/ipfs/${pinataData.IpfsHash}`;
          
          console.log('‚úÖ Uploaded to IPFS via Pinata:', metadataUri);
          
          return NextResponse.json({
            success: true,
            metadataUri,
            metadata,
            ipfsHash: pinataData.IpfsHash,
            message: 'Metadata uploaded to IPFS via Pinata. Ready to mint NFT.',
          });
        } else {
          const errorText = await pinataResponse.text();
          console.error('‚ùå Pinata error:', errorText);
          throw new Error(`Pinata upload failed: ${errorText}`);
        }
      } catch (pinataError: any) {
        console.error('‚ùå Pinata upload error:', pinataError);
        throw new Error(`Failed to upload to Pinata: ${pinataError.message}`);
      }
    }
    
    // Fallback: Use data URI if Pinata not configured
    console.log('‚ö†Ô∏è Pinata not configured, using data URI fallback');
    const metadataJson = JSON.stringify(metadata);
    const base64Metadata = Buffer.from(metadataJson).toString('base64');
    const dataUri = `data:application/json;base64,${base64Metadata}`;
    
    return NextResponse.json({
      success: true,
      metadataUri: dataUri,
      metadata,
      message: 'Metadata prepared as data URI. Ready to mint NFT.',
      note: 'Using data URI fallback. Configure PINATA_JWT for IPFS storage.',
    });
    
  } catch (error: any) {
    console.error('‚ùå Error preparing NFT metadata:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to prepare NFT metadata' },
      { status: 500 }
    );
  }
}
